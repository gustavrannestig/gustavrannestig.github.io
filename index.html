<html>
<head>
	<script type="text/javascript" src="libs/paper-full.js"></script>
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r70/three.js"></script>
	
</head>
<body>
<canvas id="paperCanvas"></canvas>
<script src="libs/TrackballControls.js"></script>
<script type="text/javascript">

var yAxisCenter;
var xAxisCenter;
var center;
var xAxisRight
var yAxisTop;

var myPath;
var firstPath;
var thirdPath;
var fourthPath;

var buttonRect;
var gridRect;

var scene, camera, renderer, controls;

//Main initializing function - should set up paper canvas and three js scene.
var init = function() {
	//The main path
	myPath = new paper.Path();
	myPath.strokeColor = 'black';

	//init render button
	var buttonPosition = new paper.Point(40,20);
	var buttonSize = new paper.Size(40, 20);
	var button = new paper.Path.Rectangle(buttonPosition, buttonSize);

	var text = new paper.PointText(new paper.Point(42, 22));
	text.justification = 'center';
	text.fillColor = 'black';
	text.content = 'Generate shape';

	button.strokeColor = 'black';
	buttonRect = new paper.Rectangle(buttonPosition, buttonSize);

	//init simple grid
	center = new paper.Point(300,300);
	yAxisCenter = new paper.Point(300,200);
	yAxisTop = new paper.Point(300, 100);
	xAxisCenter = new paper.Point(400, 300);
	xAxisRight = new paper.Point(500, 300);

	//make the axis paths
	var yAxis = new paper.Path();
	var xAxis = new paper.Path();

	yAxis.add(yAxisTop);
	yAxis.add(center);

	xAxis.add(xAxisRight);
	xAxis.add(center);

	yAxis.strokeColor = 'black';
	xAxis.strokeColor = 'black';

	//make a rect to get a box for detecting clicks inside grid.
	gridRect = new paper.Rectangle(yAxisTop, new paper.Size(200, 200));

	//add starting point to myPath
	myPath.add(yAxisCenter);

	//Add mirroring paths
	firstPath = new paper.Path();
	thirdPath = new paper.Path();
	fourthPath = new paper.Path();

	firstPath.add(yAxisCenter);
	thirdPath.add(new paper.Point(300,400));
	fourthPath.add(new paper.Point(300, 400));

	firstPath.strokeColor = 'black';
	thirdPath.strokeColor = 'black';
	fourthPath.strokeColor = 'black';

	//Draw the view
	paper.view.draw();

	//init the threejs canvas
	initThree();
	render();

	//Animate handler for three
	function animate() {
		requestAnimationFrame(animate);
		controls.update();
	}

	//Init three.js scene
	function initThree() {
		scene = new THREE.Scene();
		camera = new THREE.PerspectiveCamera(75, 500/500, 0.1, 1000 ) //Scene size absolute(500 500)
		camera.position.z = 100;
		renderer = new THREE.WebGLRenderer({ alpha: true });
		renderer.setSize(500,500);
		renderer.setClearColor(0x333F47, 1);

		//Some random lights.
	 	light = new THREE.DirectionalLight( 0xffffff );
		light.position.set( 1, 1, 1 );
		scene.add( light );

		light = new THREE.DirectionalLight( 0xffffff );
		light.position.set( -1, -1, -1 );
		scene.add( light );

		light = new THREE.AmbientLight( 0x222222 );
		scene.add( light );

		//Add controls to scene - These are trackball controls. 
		controls = new THREE.TrackballControls( camera );
		controls.addEventListener( 'change', render );

		document.body.appendChild( renderer.domElement );

		animate();
	}

	//initial render and render on controls change. 
	function render() {
		renderer.render(scene, camera);
	};
}

//Should mirror path that is drawn on each side of x and y axis.
var mirrorPath = function(point) {
	//mirror the point in the first, third and fourth qadrant
	var firstPoint = new paper.Point();
	firstPoint.x = yAxisCenter.x - (point.x - yAxisCenter.x);
	firstPoint.y = xAxisCenter.y + (point.y - xAxisCenter.y);	
	firstPath.add(firstPoint);

	var thirdPoint = new paper.Point();
	thirdPoint.x = yAxisCenter.x - (point.x - yAxisCenter.x);
	thirdPoint.y = xAxisCenter.y  + (xAxisCenter.y - point.y);
	thirdPath.add(thirdPoint);

	var fourthPoint = new paper.Point();
	fourthPoint.x = point.x;
	fourthPoint.y = thirdPoint.y;
	fourthPath.add(fourthPoint);
}

//Make shape from an array of segments(Points.)
var makeShape = function(segments) {

	var shapePts = [];

	for(var i = 0; i < segments.length; i++) {
		var vector = new THREE.Vector2 ( segments[i].point.x, segments[i].point.y );
		shapePts.push(vector);
	}

	for( var i = 0; i < shapePts.length; i ++ ) shapePts[ i ].multiplyScalar( 0.25 );

	var shape = new THREE.Shape( shapePts);

	var extrudeSettings = { amount: 1, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };

	addShape( shape,  extrudeSettings);

}

//Add shape - with additional shapes to it. in the three.js scene.
var addShape = function( shape, extrudeSettings, color) {

	var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
	geometry.center();

	var material = new THREE.MeshLambertMaterial({color: 0xFFFFFF});
	var group = new THREE.Object3D();
	var shape = new THREE.Mesh( geometry, material);
	var shape2 = new THREE.Mesh( geometry, material);
	var shape3 = new THREE.Mesh( geometry, material);
	var shape4 = new THREE.Mesh( geometry, material);
	var shape5 = new THREE.Mesh( geometry, material);
	var shape6 = new THREE.Mesh( geometry, material);
	var shape7 = new THREE.Mesh( geometry, material);
	shape2.rotation.y += (Math.PI/2);
	shape3.rotation.x += (Math.PI/2);
	shape4.rotation.y += (Math.PI/4);
	shape5.rotation.x += (Math.PI/4);
	shape6.rotation.y += (Math.PI *(3/4));
	shape7.rotation.x += (Math.PI * (3/4));
	group.add(shape7);
	group.add(shape6);
	group.add(shape5);
	group.add(shape4);
	group.add( shape3 );
	group.add( shape2);
	group.add( shape );
	scene.add(group);
	renderer.render(scene, camera);
}


window.onload = function() {
	var paperCanvas = document.getElementById('paperCanvas');
	paperCanvas.height = 500;
	paperCanvas.width = 500;
	paper.setup('paperCanvas');
	
	init();

	var tool = new paper.Tool();

	//Register mousedown tool for the paper canvas.
	tool.onMouseDown = function onMouseDown(event) {

		//If the little button is pressed we add an object. in the three.js scene.
		if(event.point.isInside(buttonRect)){

			//Connect all the paths at center of axis.
			myPath.add(xAxisCenter);
			mirrorPath(xAxisCenter);

			fourthPath.reverse()
			firstPath.reverse()

			var newPath = new paper.Path(myPath.segments);
			//Slice to avoid duplicate points. 
			newPath.addSegments(fourthPath.segments.slice(1));
			newPath.addSegments(thirdPath.segments.slice(1));
			newPath.addSegments(firstPath.segments.slice(1));
			newPath.closed = true;

			newPath.strokeColor = 'red';

			makeShape(newPath.segments);

		}

		// Add a segment to the path at the position of the mouse:
		else if(event.point.isInside(gridRect)) {
			myPath.add(event.point);
			mirrorPath(event.point);
		}
		paper.view.draw();
	}
}
</script>
</body>