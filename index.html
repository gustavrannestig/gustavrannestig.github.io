<html>
<head>
	<script type="text/javascript" src="libs/paper-full.js"></script>
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r70/three.js"></script>
	<link rel="stylesheet" href="css/style.css"></link>
	
</head>
<body>
<div class="main-wrapper">
	<div class="button-group">
		<button onclick="renderShape()">Render shape</button>
		<input type="radio" name="planes" onchange="renderShape()" checked="checked" value="1">1
		<input type="radio" name="planes" onchange="renderShape()" value="2">2
		<input type="radio" name="planes" onchange="renderShape()" value="3">3
		<input type="radio" name="planes" onchange="renderShape()" value="4">4
		<input type="radio" name="planes" onchange="renderShape()" value="5">5
		<input type="radio" name="planes" onchange="renderShape()" value="6">6
		<input type="radio" name="planes" onchange="renderShape()" value="7">7
		<label for="autoRender">Auto Render</label>
		<input type="checkbox" name="autoRender"/>
	</div>

	<div class="paper-container">
		<canvas id="paperCanvas"></canvas>
	</div>
	<div class="three-container" id="threeContainer">
	</div>
</div>
<script src="libs/TrackballControls.js"></script>
<script type="text/javascript">
var yAxisCenter;
var xAxisCenter;
var center;
var xAxisRight
var yAxisTop;

var myPath;
var firstPath;
var thirdPath;
var fourthPath;

var buttonRect;
var gridRect;

var scene, camera, renderer, controls, group;

//Main initializing function - should set up paper canvas and three js scene.
var init = function() {
	//The main path
	myPath = new paper.Path();
	myPath.strokeColor = 'black';

	var infoText = new paper.PointText(new paper.Point(300,100));
	infoText.justification = 'center';
	infoText.fillColor = 'black';
	infoText.content = 'draw by clicking here';


	//init simple grid
	center = new paper.Point(200,200);
	yAxisCenter = new paper.Point(200,100);
	yAxisTop = new paper.Point(200, 0);
	xAxisCenter = new paper.Point(300, 200);
	origo = new paper.Point(200,200);
	xAxisRight = new paper.Point(400, 200);

	//make the axis paths
	var yAxis = new paper.Path();
	var xAxis = new paper.Path();

	yAxis.add(yAxisTop);
	yAxis.add(center);

	xAxis.add(xAxisRight);
	xAxis.add(center);

	yAxis.strokeColor = 'black';
	xAxis.strokeColor = 'black';

	//make a rect to get a box for detecting clicks inside grid.
	gridRect = new paper.Rectangle(yAxisTop, new paper.Size(200, 200));

	//add starting point to myPath
	myPath.add(yAxisCenter);

	//Add mirroring paths
	firstPath = new paper.Path();
	thirdPath = new paper.Path();
	fourthPath = new paper.Path();

	firstPath.add(yAxisCenter);
	thirdPath.add(new paper.Point(200,300));
	fourthPath.add(new paper.Point(200, 300));

	firstPath.strokeColor = 'black';
	thirdPath.strokeColor = 'black';
	fourthPath.strokeColor = 'black';

	//Draw the view
	paper.view.draw();

	//init the threejs canvas
	initThree();
	render();

	//Animate handler for three
	function animate() {
		requestAnimationFrame(animate);
		controls.update();
	}

	//Init three.js scene
	function initThree() {
		scene = new THREE.Scene();
		camera = new THREE.PerspectiveCamera(75, 396/396, 0.1, 1000 ) //Scene size absolute(500 500)
		camera.position.z = 100;
		renderer = new THREE.WebGLRenderer({ alpha: true });
		renderer.setSize(396,396);
		renderer.setClearColor(0x333F47, 1);

		//Some random lights.
	 	light = new THREE.DirectionalLight( 0xffffff );
		light.position.set( 1, 1, 1 );
		scene.add( light );

		light = new THREE.DirectionalLight( 0xffffff );
		light.position.set( -1, -1, -1 );
		scene.add( light );

		light = new THREE.AmbientLight( 0x222222 );
		scene.add( light );

		//Add controls to scene - These are trackball controls. 
		controls = new THREE.TrackballControls( camera );
		controls.addEventListener( 'change', render );

		threeContainer = document.getElementById('threeContainer');

		threeContainer.appendChild( renderer.domElement );

		animate();
	}

	//initial render and render on controls change. 
	function render() {
		renderer.render(scene, camera);
	};
}

//Should mirror path that is drawn on each side of x and y axis.
var mirrorPath = function(point) {
	//mirror the point in the first, third and fourth qadrant
	var firstPoint = new paper.Point();
	firstPoint.x = yAxisCenter.x - (point.x - yAxisCenter.x);
	firstPoint.y = xAxisCenter.y + (point.y - xAxisCenter.y);	
	firstPath.add(firstPoint);

	var thirdPoint = new paper.Point();
	thirdPoint.x = yAxisCenter.x - (point.x - yAxisCenter.x);
	thirdPoint.y = xAxisCenter.y  + (xAxisCenter.y - point.y);
	thirdPath.add(thirdPoint);

	var fourthPoint = new paper.Point();
	fourthPoint.x = point.x;
	fourthPoint.y = thirdPoint.y;
	fourthPath.add(fourthPoint);
}

//Make shape from an array of segments(Points.)
var makeShape = function(segments, planes) {

	var shapePts = [];

	for(var i = 0; i < segments.length; i++) {
		var vector = new THREE.Vector2 ( segments[i].point.x, segments[i].point.y );
		shapePts.push(vector);
	}

	for( var i = 0; i < shapePts.length; i ++ ) shapePts[ i ].multiplyScalar( 0.25 );
	var shape = new THREE.Shape( shapePts);
	var extrudeSettings = { amount: 1, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };
	addShape( shape,  extrudeSettings, 0xFFFFFF, planes);
}

//Add shape - with additional shapes to it. in the three.js scene.
var addShape = function( shape, extrudeSettings, color, planes) {

	var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
	geometry.center();

	//Remove and add the group.
	scene.remove(group);
	group = new THREE.Object3D();

	var material = new THREE.MeshLambertMaterial({color: color});
	var shape = new THREE.Mesh( geometry, material);
	var shape2 = new THREE.Mesh( geometry, material);
	var shape3 = new THREE.Mesh( geometry, material);
	var shape4 = new THREE.Mesh( geometry, material);
	var shape5 = new THREE.Mesh( geometry, material);
	var shape6 = new THREE.Mesh( geometry, material);
	var shape7 = new THREE.Mesh( geometry, material);
	shape2.rotation.y += (Math.PI/2);
	shape3.rotation.x += (Math.PI/2);
	shape4.rotation.y += (Math.PI/4);
	shape5.rotation.x += (Math.PI/4);
	shape6.rotation.y += (Math.PI *(3/4));
	shape7.rotation.x += (Math.PI * (3/4));

	group.add( shape );

	//switch for number of planes.
	if(planes > 1) {
		group.add( shape2 );
	}
	if(planes > 2) {
		group.add( shape3 );
	}
	if (planes > 3) {
		group.add( shape4 );
	}
	if (planes > 4) {
		group.add(shape5);
	} 
	if (planes > 5) {
		group.add(shape6);
	}
	if (planes > 6) {
		group.add(shape7);
	}

	scene.add(group);
	renderer.render(scene, camera);
}


var renderShape = function() {

	var newPath = new paper.Path(myPath.segments);
	var tempFourth = new paper.Path(fourthPath.segments);
	var tempThird = new paper.Path(thirdPath.segments);
	var tempFirst = new paper.Path(firstPath.segments);

	tempFourth.reverse()
	tempFirst.reverse()
	newPath.join(tempFourth);
	newPath.join(tempThird);
	newPath.join(tempFirst);
	newPath.closed = true;

	newPath.strokeColor = 'red';

	//Get number of planes - plain js to avoid having to import for ex jquery.
	var radios = document.getElementsByName('planes');

	for (var i = 0, length = radios.length; i < length; i++) {
	    if (radios[i].checked) {
	        planes = parseInt(radios[i].value);
	        break;
	    }
	}

	makeShape(newPath.segments, planes);
	paper.view.draw();
	newPath.remove();
}

window.onload = function() {
	var paperCanvas = document.getElementById('paperCanvas');
	paperCanvas.height = 500;
	paperCanvas.width = 500;
	paper.setup('paperCanvas');
	
	init();
	
	var tool = new paper.Tool();
	var tooldistanceThreshold = 2;
	//Register mousedown tool for the paper canvas.
	tool.onMouseDown = function onMouseDown(event) {


		if(event.point.x < (origo.x + 2) && event.point.x > (origo.x - 2) && event.point.y > (yAxisTop.y - 2) && event.point.y < (origo.y + 2)) {
			myPath.segments = myPath.segments.slice(1);
			myPath.insert(0,new paper.Point(origo.x, event.point.y ));

			firstPath.segments = firstPath.segments.slice(1);
			firstPath.insert(0, new paper.Point(origo.x, event.point.y));

			thirdPath.segments = thirdPath.segments.slice(1);
			thirdPath.insert(0, new paper.Point(origo.x, (origo.y + (origo.y - event.point.y ))));
			fourthPath.segments = fourthPath.segments.slice(1);
			fourthPath.insert(0, new paper.Point(origo.x, (origo.y + (origo.y - event.point.y ))));

		}
		// Add a segment to the path at the position of the mouse:
		else if(event.point.isInside(gridRect)) {
			myPath.add(event.point);
			mirrorPath(event.point);
		}
		paper.view.draw();

		var autoRender = document.getElementsByName('autoRender')[0].checked;
		if (autoRender) {
			renderShape();
		}
	}

	tool.onMouseMove =function onMouseMove(event) {

		if(event.point.x < (origo.x + 2) && event.point.x > (origo.x - 2) && event.point.y > (yAxisTop.y - 2) && event.point.y < (origo.y + 2)) {
			var point = new paper.Point(origo.x, event.point.y);
			var yAxisCircle = new paper.Shape.Circle(point, 5);
			yAxisCircle.strokeColor = 'black';
			yAxisCircle.removeOnMove();
		}
		paper.view.draw();
	}
}
</script>
</body>